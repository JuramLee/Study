
자바스크립트의 스레드
    자바스크립트는 싱글 스레드( = 일꾼)

싱글 스레드인 자바스크립트의 특징 중 하나인
현재 실행중인 태스크가 종료되어야만 다음 테스크를 실행하는것
 => 해당 특징 떄문에 처리 시간이 지연ㄴ되는 경우 비효율적

따라서 자바스크립트는 이벤트 루프를 활용하여 기존의 테스크가 종료되지 않아도
다음 테스트를 곧바로 실행하는 방식인 비동기를 도입하였다.

비동기를 도입함으로써 여러 테스크를 동시에 처리할 수 있으며,
정확히는 사람이 인지할 수 없을 정도의 찰나의 순간 순차적으로 실행

단점으로는 비동기로 실행되는 테스크의 실행순서가 보장되지 않음

그러나 실행 순서가 보장되지 않으므로 사용되는 매개변수가 달라지는 경우가 발생
=> 비동기 처리

ex) 상품정보(2초), 상품 목록(0.1초) ---> 상품기능(2.1초)

============================================================================

동기 (순차적인 흐름) vs 비동기 (지연, 블록킹 현상이 일어나는 것을 동시에 실행)

----------------------------------------------------------------------------

    - 대표적인 비동기 함수
      setTimeOut, setInterval, Promise

============================================================================

비동기 처리
    비동기는 처리 시간이 각각 다르기 떄문에 결과를 예상할 수 없음
    따라서 결과에 따라 다음 함수(비동기, 동기 함수)를 실행 시켜주기 위하여 사용

방법
    1) call back
        콜백함수로서 비동기 이후 실행해야할 함수를 인자로 받고 
        해당 비동기 함수가 실행되면 실행하는 방식

        * call back hell
         콜백 지옥이란, 콜백함수를 익명함수로 전달하는 과정에서 또 다시 콜백 호출이 반복되어
         들여쓰기 수준이 감당하기 힘들 정도로 깊어진 상태

         주로 이벤트 처리나, 비동기 작업을 제어(비동기처리)를 하기 위하여 사용되는ㄴ데
         이러한 프로그래밍은 가독성이 떨어지고 유지 보수를 어렵게 한다

    2) promise
        ES6, promisse는 new 연산자와 함께 호출하고 인자로 콜백을 받습니다.
        promise는 호출 시에 바로 실행되지만, 그 안에 resolve와 reject 둘 중 하나가 호출되기
        전에는 then이나 catch로 넘어가지 않는다

        then = 성공했을 때 (resolve의 결과 값을 인자로 받는다)
        catch = 실패했을 때 (reject의 결과 값을 인자로 받는다)

        예를 들면 서버에서 데이터 받기가 성공했다면 결과 값은 resolve에 넘겨 then을 호출하고실패했다면 결과값(에러)를 reject에 넘겨 catch를 호출한ㄴ다

        ex)
        const result = new Promise((resolve, reject) => {
            비동기 호출..
            비동기가 성공했을 때 resolve(res.data)
            비동기가 실패했을 때 reject(err)
        })

        result.then((res) => console.log(res))
        result.catch((err) => console.log(err))

    3) async await
        Promise로 비동기 처리를 한다고 하더라도 콜백지옥이 연상되는 것은 마찬가지
        따라서 ES2017에 추가된 async await의 경우는
        비동기 작업을 수행하고자 하는 함수 앞에 async를 표기
        ( => 아직 적용은 안되었지만 최신 자바스크립트에서는 async를 표기 하지 않아도 실행가능)

        async: 함수를 promisse형태로 반환
        await: 해당 함수가 실행될 때까지 promise가 resolve 될 때까지 대기

============================================================================

무료 JSON 데이터 테스트 : https://jsonplaceholder.typicode.com

============================================================================

ajax -> 제이쿼리랑 씀
    Asynchronous Javascript and XML의 약자
    본래 의미는 javascript를 활용한 비동기 통신, 클라이언트와 서버 간의 데이터를 주고 받는 기술

ex)
좋아요 버튼을 누를 때 마다 DB 저장소에 좋아요 숫자가 저장 되어있고 해당 값이 1씩 추가될 것
(테이블에 데이터가 추가되는 것. 전체 데이터량이 1 늘어나는 것 => 정확히는 길이가 1씩 늘어남 length)
그렇다면, 프론트엔드의 화면은 값이 바뀌어있을까? => NO

해결 방법
    1. innerHTML 숫자 가져와서 +1 해준다 but 실패하면? => 데이터가 정확하지 않다
    2. 좋아요 버튼 누를 때마다 새로고침 => 사용자 입장에서는 새로고침이 불편
    3. ajax, axios, fetch와 같은 서버와 비동기 통신을 위해 만들어진 라이브러리를 활용하여
       성공과 실패 여부에 따라 백엔드에서 받아온 결과값을 가지고 DOM API조작 => 데이터 확신

============================================================================

axios / fetch

기존의 web에서는 어떠한 비동기 요청을 위해 XML HTTP REQEUST객체를 사용했어야 했다(ajax)
그러나 이러한 XHR은 요청의 상태나 변경에 따라 개발자의 의도에 맞게 사용하기에는 적합하지 않음
이를 보완하기 위하여 HTTP요청에 최적화 되고 상태 추상화도 잘 되어있는 api들이 생겨나기 시작함

대표적으로 axios, fetch

    * fetch
      ES6부터 Javascript 내장되어 있어 안정성이 뛰어남
      promise 기반으로 만들어졌으며 코드 또한 간편함!

      ex)

      option(method, header ...)

      fetch(url, option)
      .then()
      .catch()

      fetch(url, {
        method: "POST"
        header: {
            "Accept": "application/json",
            "Content-Type": "application/json;charset=UTF-8"
        },
        body:JSON.stringfy({
            ...data
        })
      }).then()
      .chatch()

    ---------------------------------------------------------------------

    * axios
      내장 X 설치 및 cdn으로 라이브러리를 가지고 와서 사용
      promise 기반
      크로스 브라이징에 신경을 썼기 때문에 거의 모든 브라우저와 호환
      다양한 기능을 지원 (ex. timeout, interceptor ...)
      => https://axios-http.com/kr/docs/intro

      단점: 라이브러리를 설치해야하기 때문에 의존성이 높아진다.

============================================================================

API
    두 소프트웨어가 서로 통신할 수 있도록 하는 매커니즘의 한 종류

    ex)
    기상청 소프트웨어는 일일 기상 데이터를 제공
    핸드폰의 소프트웨어는 해당 기상청 소프트웨어와 API를 통해 데이터를 교환하여
    핸드폰에 최신의 날씨 정보를 업데이트

REST API
    자원(데이터)을 이름으로 구분하여 해당 데이터의 상태를 주고받는 모든 것
    API에 이름을 주는 것

    ex)
    인터넷 게시판에 글을 등록하는 거라면
    post method를 활용한 '/posts'

    단점: 유사한 데이터라고 하더라도 사용 목적에 따라서 REST API를 지키기 위해서
          다른 API 주소를 생성. 즉, 불필요한 데이터가 포함되는 경우가 많다.

        * REST API <-> graphQL (json 데이터를 주고 받는 것 => REST API의 단점 보완)


method
    개발자들 사이의 REST API를 위한 약속
    보통은 백엔드에서 해당 요청이 어떤 method인지 정해주니 해당 method에 맞게 req를 보내면 됨
    (api 문서, swagger를 통해 문서화되어 관리, test case)

    get     : 얻다, 가져오다 (조회) => body없이 url(주소)로만 전송

        * 주소에 데이터를 싣는 방법
            qs(params)
                "http://백엔드주소.com/?id=5&content=smile"
            (req.query.id = 5)
            (req.query.content = "smile")

            param
                "http://백엔드주소.com/220534332?loc_good=rank"
            "/:prodId"

            (req.param.prodId = 220534332)
            (req.query.loc_good = rank)
        
    post    : 물품을 보내다 (생성), data를 보내야할 필요가 있음 
              ( body에 data를 실어 보낸다 ) => url and body
    put     : 놓다 (수정), 모든 데이터를 수정(기존에 있던 데이터 대신해서 놓는다)
    patch   : 작은 조각들, 일부 데이터를 수정
    delete  : 삭제 (삭제)

  * get만 body가 없다.
  * 백엔드와 API, HTTP를 통해 소통

    HTTP request message
        header 데이터의 형태, 보안, 설정 [title]
        body 실제 데이터 json형태의 데이터 [content]
    
============================================================================

location 객체
    자바스크립트의 window가 갖는 빌트인 그러나 window 생략이 가능.
    현재 인터넷 창의 URL(주소)을 나타내는 객체

  메소드(함수)
    assign      새로운 주소 이동, history가 남는다(뒤로가기 가능)
    replace     새로운 주소 이동, history가 남지 않는다(뒤로가기 불가능) => 보통 로그인해주세요 창
    reload      새로고침 
  
  속성(property)
    href        현재의 URL을 반환하고 있기 때문에 해당 속성이 변화되면 해당 주소로 이동
    hash        #뒤에 붙은 값을 가지고 온다
    hostname    URL의 도메인(프로토콜, 포트 제외)
    origin      전체주소. 프로토콜 +  URL의 도메인 + 포트
    pathname    원본 주소 제외 경로를 가져온다 /posts
    port        현재 사이트의 포트번호
    protocol    http:를 가져온다
    search      URL에 붙은 쿼리 값을 가지고 온다 ?postId=3


history 객체
    URL 방문 기록을 조회하여 이전페이지 혹은 다음 페이지로 이동시킬 수 있는 객체

    ex)
    history.back()  바로이전페이지
    history.go(-n)  n번 이동
    history.forward() 바로다음페이지     // history가 있어야만 감










































