
React?
    복잡한 사용자 인터페이스(UI)를 쉽게 구축하기 위해 페이스북에서 제작한 라이브러리

    라이브러리? (도서관 = 모듈들의 집합)

    프레임워크와 라이브러리의 차이점
        - 프레임워크 : 코드를 작성할 때 필요한 틀을 제공해주는 것. 따라서 개발을 할 때 제어권이 개발자가 아닌 프레임워크에 존재.
                    개발할 때 프레임워크가 가지고 있는 규칙에 의해 작성
                ex) spring, django, nextJS, nuxtJS

        - 라이브러리 : 같은 로그인 로직이라 하더라도 passportJS, gotrue 등 중에 선택. 제어권이 개발자에게 있다.
                    즉, 사용자는 특정 정해져있는 코드를 사용하는 것이 아니라, 필요로 하는 라이브러리를 선택해서 코드에 적용
                ex) nodeJS 설치되는 모든 패키지, reactJS, jquery


-------------------------------------------------------------------------------------------------------------------------------------------------

React의 JS 구동원리 핵심 컨셉  

    Components
        - 하나의 페이지를 한 가지 이상의 기능을 수행하는 UI 단위로 분리한 것
        - 재사용이 용이하고 관리 및 유지 보수에 효율적

    Virtual DOM
        - React가 가지고 있는 가상 DOM, DOM의 복사본
        - state(상태)를 react에서 구독, 만약 state의 변화가 생긴다면 그 때 가상돔과 실제돔을 비교하요 수정된 부분만을 실제돔에 리랜더링

            * state의 변화가 생긴다면
            * 수정된 부분(state에 변경이 생긴 component)만을 실제 돔에 리랜더링 ( => 랜더링 최적화 )

        ** KEY POINT **
            state(상태, 값)
            Component(UI 분리)
            Virtual DOM (re-rendering)

-------------------------------------------------------------------------------------------------------------------------------------------------

CSR, SSR

    CSR(Client Side Rendering) : 사용자가 웹 페이지를 그린다.
        사용자가 웹 페이지 접속 -> 프론트엔드 서버에 페이지를 랜더링 할 때 필요한 리소스 전달

        ex) 페이지가 로드 되었을 때 상품 목록을 그려준다. 이 상품 목록은 백엔드 서버로부터 응답 받은 데이터이다.
            => 이 과정을 사용자가 하게 되는 것. 즉, 사용자가 랜더링을 부담

        장점 : 페이지에 필요한 리소스들을 사전에 미리 불러와 데이터를 캐싱(저장)하고 있다가 
               URL에 맞는 페이지를 보여주기 때문에 초기 랜더링 이후의 랜더링 속도가 빠르다.
        단점 : 초기 페이지 로딩이 SSR보다 느리다. SEO(검색엔진최적화)에 불리하다. 
               따라서 검색엔진에 노출이 필요한 사이트에 부적합하다. (검색엔진 검색하였을 때 페이지에 빈화면이 노출)

    SSR(Server Side Rendering) : 서버에서 페이지를 그린다.
        사용자가 웹 페이지에 접속 -> 서버에서 페이지를 랜더링 -> 랜더링된 페이지를 사용자에게 전달
        js가 로드 되기도 전에 완성된 페이지를 사용자가 먼저 확인 (기능은 X)

        장점 : SEO 유리 => 웹 사이트를 검색엔진이 크롤링하여 사용자에 제공 가능
               빠른 완성본 페이지 로딩 속도. 서버에서 랜더링을 부담하기 때문에 사용자가 느끼는 부담이 덜하다.
        단점 : 서버에 부담(생산 비용 증가) 무거운 페이지라면 오히려 초기 로딩이 CSR보다 오래 걸릴 가능성이 높다
               CSR보다 더 많은 생산비용, 추가 러닝 커브

    React는 대표적인 CSR, SPA이다.

-------------------------------------------------------------------------------------------------------------------------------------------------

SPA, MPA

    SPA(Single Page Application) : 말 그대로 페이지가 1인 애플리케이션(.html 파일이 1개)
        reactJS와 같은 컴포넌트 기반 라이브러리 및 프레임워크는 SPA에 최적화
        사용자가 웹사이트에 접속 당시 번들링 된 리소스들을 한번에 전달. 
        그리고 이를 캐싱해두었다가 url이 달라짐에 따라 html의 내부를 수정하여 사용자에게 보내주는 것
        따라서 통상적으로 react의 파일 구조는 index.html 하나로만 구성되어 있음

    MPA(Multi Pages Application) : 페이지가 여러개인 애플리케이션(.html 파일이 여러개)
        보통은 SSR 방식으로 요청마다 해당 페이지에 필요한 리소스를 불러온다.

-------------------------------------------------------------------------------------------------------------------------------------------------

* React는 CSR에 SPA에 최적화 되어 있다.

-------------------------------------------------------------------------------------------------------------------------------------------------

패키지 관리 툴
    라이브러리들을 관리하고 설치할 수 있는 도구
    npm, npx, yarn, yarn berry

    - npm
        nodeJS에서 기본적으로 내장되어 있는 패키지 관리 툴
        ex) npm i(install) 라이브러리 명(--save) : 설치
            npm rm(remove) 라이브러리 명 : 삭제
            npm i -g 라이브러리명 : 노드 환경 전역에서 설치
            npm i -D 라이브러리명 : 개발환경에서만 사용할 라이브러리를 설치 => 디버깅 툴은 개발자만 보고 사용자가 굳이 볼 필요 없을 때 이용

    - npx
        npm과 달리 설치하지 않고 라이브러리를 실행시켜주는 도구
        사실 개발하는 입장이라면 npm과 npx 차이를 느끼지 못할 수도 있음
        단, npx를 사용해야하는 경우는 내 프로젝트에 설치하지 않고 일회성으로 무거운 패키지를 사용해야할 때 설치없이 실행하는 패키지 관리 툴
        npx도 마찬가지로 npm에 기본 설치(5.2v 이상)
        ex) npx create-react-app 프로젝트명 : react 프로젝트를 생성하는 명령어 (CRA)

    - yarn
        과거에는 npm보다 속도, 안정성, 보안 모두 뛰어나서 이목을 끌었다가 npm의 잦은 업데이트로 현재는 거의 차이가 없는 상태. 보안성은 제외

    - yarn berry
        npm과 yarn의 경우는 설치된 라이브러리들은 bode_modules라고 하는 파일에 저장
        pnp 방식을 도입 -> zero install
        알집으로 파일을 관리하고 있기 때문에 프로젝트 자체가 가볍고 빌드가 빨라진다.

    ** 모노레포
        하나의 워크스페이스(폴더)를 통해 여러개의 프로젝트를 담고 관리할 수 있음
        본래 모노레포는 yarn과 turbo 라이브러리를 통해 구축하였으나 yarn berry는 보다 모노레포에 최적화 되어있는 패키지 관리 툴
        그러나, 다른 프로젝트를 한 폴더에 둔다는 것은 폴더의 구조나 신경써야하는 부분들이 배로 늘어난다는 이야기
        따라서 초기에 적용하는 것은 좋지 않고 이미 사용자가 충분히 확보된 복잡한 프로젝트를 간단하게 만들기 위해 사용
        
-------------------------------------------------------------------------------------------------------------------------------------------------

React 생성
    1. 터미널 명령어를 통해 내가 프로젝트를 생성하고자 하는 위치 경로를 맞춰야함
    2. 명령어
        create-react-app (CRA) webpack5(번들링 도구) => react에서 직접 만든 명령어. 굉장히 편리한 라이브러리들이 이미 설치 및 세팅됨
        vite esBuild(번들링없이 빨리 만드는 것) => 초보자가 사용하기에 적합하지 않음
        CRA는 react에 필요한 모든 설정 파일을 대신 설정해줌(webpack과 같은 번들링도구, 바벨과 같은 트랜스파일러)
        단점 : 이미 설치된 도구를 커스텀하기 힘들다. 보통의 경우 커스텀을 할 때는 carco와 같은 CRA 전용 설정 라이브러리를 통해 커스텀 해야한다.

    3. npx create-react-app 프로젝트명
        * 폴더 경로 꼭 확인
            cd ex1
            npm start
        * react 실행의 기본 port는 3000번
            따라서 프로젝트 실행 시 기본 주소는 http://localhost:3000/
            프로젝트가 실행 중일때는 port번호가 변함 3001, 3002 ...


-------------------------------------------------------------------------------------------------------------------------------------------------

webpack (= 모듈 번들러)
    모듈 => 한가지 이상의 기능을 하는 분리된 코드의 집합. 덩어리
    번들러 => 묶어주는 것

    html, css, js, img
    너저분하게 분리되어있는 리소스들을 확장자명 혹은 특정 기준으로 분류하고 묶어주는 역할

    모듈 번들러인 웹팩을 사용하면 잘 정돈되어있는 데이터에서 필요한 리소스만 찾을 수 있기 때문에 네트워크 연산 비용이 줄어듦

    * 장점
        1. 모듈 단위의 개발이 가능
        2. 네트워크 연산 비용 감소
        3. loader라는 기능을 통해 js가 로드할 수 없는 파일도 로드할 수 있는 상태로 컴파일(변환)

babel (= 트렌스파일러, 번역기)
    ES6(ES2015) 이후 -> 모던 자바스크립트

    최신 문법들을 이해하지 못하는 웹 브라우저 로더들 존재(ex Internet Explorer).
    이 로더들이 해당 언어를 이해할 수 있도록 저레벨의 문법으로 트랜스파일해서 이해할 수 있도록 변환

    ** react에서 babel 중 4가지 모듈을 사용
        1. @babel/core          : 바벨을 구동시키기 위한 핵심 요소
        2. @babel/cli           : 명령어를 통해 cmd에서 바벨 명령어 사용 가능
        3. @babel/preset-env    : 바벨의 가장 기본적인 설정들
        4. @babel/preset-react  : 바벨을 JSX문법(react 문법)도 이해할 수 있도록 해주는 모듈

-------------------------------------------------------------------------------------------------------------------------------------------------

    * 개발자로서의 가치관? 비즈니스를 이해하고 생산성에 기여하는 개발자
        가치 및 이익을 창출 할 수 있는..

-------------------------------------------------------------------------------------------------------------------------------------------------

리액트 프로젝트 구조

    node_modules : 현재 프로젝트에 설치된 라이브러리들의 실제 파일. 용량이 높은 편. 그래서 git에는 올리지 않는다.
        * npm install(npm i)해서 node_modules 설치

    public : 정적 파일 보관소 (index.html, favicon, SEO ...)
   *src : 개발이 진행될 곳
   .gitignore : git에 올라가지 말아야할 파일
    package.json : 설치된 라이브러리의 목록과 버전을 관리, 실행 스크립트(명령어)와 프로젝트 설정
    package-lock.json : 라이브러리 설치 시, 라이브러리 설치에 필요한 정확한 정보
    
-------------------------------------------------------------------------------------------------------------------------------------------------

src의 구조
    App.css : App.js에 참조되어 있는 기본 css파일 (지워도 무방)
        * index.js, app.js는 react 구조상 index.html을 제외한 최상위 컴포넌트. App.css는 모든 컴포넌트에 적용
          그러나 react에서 가장 많이 사용하는 것은 일반적인 css가 아닌 js안에 css를 작성할 수 있는 CSS-in-JS를 활용
          따라서 삭제해줘도 무방 (CSS-in-JS에 전역 스타일링 기능이 따로 탑재되어있기 때문)
    App.js : routing, 라이브러리의 provider(설정 파일들을 위치시킨다)
    App.test.js : test코드의 샘플
    index.css : App.css와 동일
    index.js : 최상위 컴포넌트의 index.html의 root에 App.js를 rendering(전달)시켜주는 역할
    reportWebVitals.js : 프론트엔드 성능 체크하는 기능, 체크x (라이트하우스 체크o)
    setupTests.js : testCode 라이브러리의 전역 참조 설정

-------------------------------------------------------------------------------------------------------------------------------------------------


CSR : 사용자가 페이지 랜더링 (호스팅 - 파일에 리소스만 전달하면 되서 서버가 필요없음)
SSR : 서버가 페이지 랜더링 (프론트엔드도 웹서버가 필요함)
SPA : 페이지 1개
MPA : 페이지 여러개

Bundler 번들러 : 모듈을 묶어주는 것. 정리가 잘 됨
Babel 바벨 : 트랜스파일러 해석, 번역기.

---------------------------------------------------------------------------------------------------------

React는 CSR, SPA에 최적화되어있다.

---------------------------------------------------------------------------------------------------------

